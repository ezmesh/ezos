#!/usr/bin/env python3
"""
Embed Lua scripts into firmware binary.
Generates a C++ file with all Lua scripts as const char arrays.

Can be run:
1. As a PlatformIO pre-build script (via extra_scripts)
2. Directly from command line (python scripts/embed_lua_scripts.py)
"""

import os
import sys
from pathlib import Path

# Size limits for warnings
SIZE_WARNING_THRESHOLD = 800 * 1024  # 800KB - warn when approaching
SIZE_ERROR_THRESHOLD = 1024 * 1024   # 1MB - error if exceeded


def escape_string_for_c(data: bytes) -> str:
    """Convert bytes to C string literal content with proper escaping."""
    result = []
    for b in data:
        if b == ord('\\'):
            result.append('\\\\')
        elif b == ord('"'):
            result.append('\\"')
        elif b == ord('\n'):
            result.append('\\n')
        elif b == ord('\r'):
            result.append('\\r')
        elif b == ord('\t'):
            result.append('\\t')
        elif 32 <= b < 127:
            result.append(chr(b))
        else:
            result.append(f'\\x{b:02x}')
    return ''.join(result)


def generate_var_name(path: str) -> str:
    """Generate a valid C variable name from a path."""
    name = path.lstrip('/')
    name = ''.join(c if c.isalnum() else '_' for c in name)
    return f"lua_{name}"


def find_lua_scripts(data_dir: Path) -> list:
    """Find all .lua files and return (virtual_path, file_path) tuples."""
    scripts_dir = data_dir / "scripts"
    if not scripts_dir.exists():
        return []

    scripts = []
    for lua_file in scripts_dir.rglob("*.lua"):
        relative = lua_file.relative_to(data_dir)
        virtual_path = "/" + str(relative).replace("\\", "/")
        scripts.append((virtual_path, lua_file))

    scripts.sort(key=lambda x: x[0])
    return scripts


def generate_embedded_scripts_cpp(scripts: list, output_path: Path) -> int:
    """Generate the C++ file with embedded scripts. Returns total size."""
    total_size = 0
    script_data = []

    for virtual_path, file_path in scripts:
        content = file_path.read_bytes()
        total_size += len(content)
        script_data.append((virtual_path, content))

    lines = [
        "// AUTO-GENERATED FILE - DO NOT EDIT",
        "// Generated by scripts/embed_lua_scripts.py",
        "//",
        f"// Total embedded Lua scripts: {len(scripts)}",
        f"// Total size: {total_size:,} bytes ({total_size/1024:.1f} KB)",
        "",
        '#include "embedded_lua_scripts.h"',
        '#include <cstring>',
        "",
        "namespace embedded_lua {",
        "",
    ]

    for virtual_path, content in script_data:
        var_name = generate_var_name(virtual_path)
        escaped = escape_string_for_c(content)
        lines.append(f"// {virtual_path} ({len(content)} bytes)")
        lines.append(f'static const char {var_name}[] = "{escaped}";')
        lines.append("")

    lines.append("// Lookup table")
    lines.append("static const struct {")
    lines.append("    const char* path;")
    lines.append("    const char* content;")
    lines.append("    size_t size;")
    lines.append("} scripts[] = {")

    for virtual_path, content in script_data:
        var_name = generate_var_name(virtual_path)
        lines.append(f'    {{"{virtual_path}", {var_name}, {len(content)}}},')

    lines.append("};")
    lines.append("")
    lines.append(f"static const size_t script_count = {len(scripts)};")
    lines.append("")

    lines.extend([
        "const char* get_script(const char* path, size_t* out_size) {",
        "    for (size_t i = 0; i < script_count; i++) {",
        "        if (strcmp(scripts[i].path, path) == 0) {",
        "            if (out_size) *out_size = scripts[i].size;",
        "            return scripts[i].content;",
        "        }",
        "    }",
        "    return nullptr;",
        "}",
        "",
        "size_t get_script_count() {",
        f"    return {len(scripts)};",
        "}",
        "",
        "size_t get_total_size() {",
        f"    return {total_size};",
        "}",
        "",
        "const char* get_script_path(size_t index) {",
        "    if (index >= script_count) return nullptr;",
        "    return scripts[index].path;",
        "}",
        "",
        "size_t get_script_size(size_t index) {",
        "    if (index >= script_count) return 0;",
        "    return scripts[index].size;",
        "}",
        "",
        "} // namespace embedded_lua",
        "",
    ])

    output_path.write_text('\n'.join(lines))
    return total_size


def generate_header(output_path: Path):
    """Generate the header file."""
    lines = [
        "// AUTO-GENERATED FILE - DO NOT EDIT",
        "// Generated by scripts/embed_lua_scripts.py",
        "",
        "#pragma once",
        "",
        "#include <cstddef>",
        "",
        "namespace embedded_lua {",
        "",
        "// Get embedded script content by path (e.g., \"/scripts/boot.lua\")",
        "// Returns nullptr if not found, sets out_size if provided",
        "const char* get_script(const char* path, size_t* out_size = nullptr);",
        "",
        "// Get total number of embedded scripts",
        "size_t get_script_count();",
        "",
        "// Get total size of all embedded scripts in bytes",
        "size_t get_total_size();",
        "",
        "// Get script path by index (0 to get_script_count()-1)",
        "const char* get_script_path(size_t index);",
        "",
        "// Get script size by index",
        "size_t get_script_size(size_t index);",
        "",
        "} // namespace embedded_lua",
        "",
    ]
    output_path.write_text('\n'.join(lines))


def embed_lua_scripts(project_root: Path) -> int:
    """Main embedding function. Returns 0 on success, 1 on error."""
    data_dir = project_root / "data"
    src_dir = project_root / "src"
    output_cpp = src_dir / "lua" / "embedded_lua_scripts.cpp"
    output_h = src_dir / "lua" / "embedded_lua_scripts.h"

    scripts = find_lua_scripts(data_dir)

    if not scripts:
        print("WARNING: No Lua scripts found in data/scripts/")
        generate_header(output_h)
        output_cpp.write_text(
            "// AUTO-GENERATED FILE - DO NOT EDIT\n"
            "// No Lua scripts found\n"
            '#include "embedded_lua_scripts.h"\n'
            "namespace embedded_lua {\n"
            "const char* get_script(const char*, size_t*) { return nullptr; }\n"
            "size_t get_script_count() { return 0; }\n"
            "size_t get_total_size() { return 0; }\n"
            "const char* get_script_path(size_t) { return nullptr; }\n"
            "size_t get_script_size(size_t) { return 0; }\n"
            "}\n"
        )
        return 0

    print(f"Embedding {len(scripts)} Lua scripts...")

    generate_header(output_h)
    total_size = generate_embedded_scripts_cpp(scripts, output_cpp)

    print(f"  Total size: {total_size:,} bytes ({total_size/1024:.1f} KB)")
    print(f"  Output: {output_cpp}")

    # Size warnings
    if total_size > SIZE_ERROR_THRESHOLD:
        print(f"\n*** ERROR: Embedded Lua scripts exceed {SIZE_ERROR_THRESHOLD/1024:.0f}KB limit! ***")
        print(f"    Current size: {total_size/1024:.1f}KB")
        print("    Consider removing or optimizing scripts.")
        return 1
    elif total_size > SIZE_WARNING_THRESHOLD:
        pct = (total_size / SIZE_ERROR_THRESHOLD) * 100
        print(f"\n*** WARNING: Embedded Lua scripts at {pct:.0f}% of {SIZE_ERROR_THRESHOLD/1024:.0f}KB limit ***")
        print(f"    Current size: {total_size/1024:.1f}KB")
        print(f"    Remaining: {(SIZE_ERROR_THRESHOLD - total_size)/1024:.1f}KB")

    return 0


# PlatformIO pre-build hook - runs immediately when script is loaded
try:
    Import("env")

    # Check if NO_EMBEDDED_SCRIPTS is defined (sdcard build)
    # Check in CPPDEFINES which is where -D flags end up
    cpp_defines = env.get("CPPDEFINES", [])
    build_flags = env.get("BUILD_FLAGS", [])

    # Check both CPPDEFINES and BUILD_FLAGS for the define
    skip_embedding = False
    for d in cpp_defines:
        if isinstance(d, tuple):
            if d[0] == "NO_EMBEDDED_SCRIPTS":
                skip_embedding = True
                break
        elif d == "NO_EMBEDDED_SCRIPTS":
            skip_embedding = True
            break

    if not skip_embedding:
        skip_embedding = any("NO_EMBEDDED_SCRIPTS" in str(f) for f in build_flags)

    if skip_embedding:
        print("NO_EMBEDDED_SCRIPTS defined - skipping script embedding")
    else:
        # Run embedding immediately during script load (before compilation)
        project_dir = Path(env.get("PROJECT_DIR", "."))
        result = embed_lua_scripts(project_dir)
        if result != 0:
            env.Exit(1)

except Exception as e:
    # Not running under PlatformIO - allow direct execution
    print(f"Note: Not running under PlatformIO ({e})")
    pass


def main():
    """Direct execution entry point."""
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    return embed_lua_scripts(project_root)


if __name__ == "__main__":
    sys.exit(main())
